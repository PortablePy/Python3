"""Framework for TCP server to handle Multiple clients over the network"""
import socketserver
import typing


class PortHandler(socketserver.BaseRequestHandler):
    """
    Inherited from socketserver.BaseRequestHandler class, for handling each client asynchronously.
    All the connection management operations, including message encoding and decoding is handled by
    this class. This class defines an additional methods named query and query_process,
    which handles the core text slicing and text processing operation. Text Processing defined by
    the query_process in this class is a simple loopback logic which acts as a template. This needs
    to be overwritten by the subclasses based on the requirements.

    Args:
        socketserver.BaseRequestHandler (class): for inheritance.
    """

    def handle(self):
        """
        Handles the connection and talks to each of the connected client asynchronously.
        This method handles network communication (send, receive and close connections) and
        delegates the core logic to the query method. Receives the data in raw byte format.

        Args:
            self: connection end point details of each client.
        """
        while True:
            try:
                hex_data = bytearray(b"")  # Create empty buffer to store bytes
                hex_byte = b""  # create variable to store byte reading
                while hex_byte != b"\n":
                    hex_byte = self.request.recv(1)  # read one byte
                    hex_data.append(hex_byte[0])  # build buffer till newline
                line_text = hex_data.decode()  # decode the entire line text
                reply = self.query(line_text)  # delegate the processing
                self.request.sendall(reply.encode())  # send the response back
            except Exception as error:
                print("unhandled Error from", self.client_address, ":", error)
                break
        self.request.close()

    def query(self, command: str):
        """
        Trims the input command line and splits them into several words and calls
        query_process method. Appends EOL character to the response string.
        This method can be overloaded by the caller if non text based processing is required.

        Args:
            command (str): Unicode command line string received by the TCP port.

        Returns:
            response(str): Unicode string response to be transmitted back via the TCP Port.
        """
        line = command.lstrip().rstrip()  # removes non printable chars at beginning and ending
        words = line.split(" ")  # and split the line into words
        cmd = words.pop(0)  # first word of the line is referred as command
        args = words  # rest of the words are arguments
        reply = self.query_process(cmd, args)  # delegate the processing to another function
        response = reply + "\r\n"  # append EOL to reply
        return response

    def query_process(self, cmd: str, args: typing.List[str]):
        """
        Base port query process method. This is a simple loopback by default.
        This method must be overloaded by the caller based on the use case.

        Args:
            cmd (str): command that identifies specific operation
            args (typing.List[str]): additional options / arguments needed for the operation

        Returns:
            reply(str): This is the reply to the command with arguments received.
        """
        reply = cmd + " " + " ".join(args)
        print(self.client_address, ":", reply)
        return reply
